mod=1000000007
n=int(input())
dp=[]
for i in range(n+1):
  dp.append([])
  for j in range(10) :
    dp[-1].append([])
    for k in range(6) :
      dp[-1][-1].append(0)

for i in range(10) :
  dp[1][i][3] = 1

for i in range(2,n+1) :
  for j in range(10) :
    if j == 0 : 
      #마지막 수가 0이라면 그 앞에는 1만 올 수 있으므로 감소하는 경우 밖에 없음.

      #이미 1번 감소한 상태
      #감소한 상태에서 또 감소하므로 3차원 배열 인덱스는 1로 바뀐다.
      dp[i][0][1] = dp[i][0][1] + dp[i-1][1][2]

      #감소한 적이 없는 상태
      #마지막 수로 0이 오면서 감소하기 때문에 3차원 배열 인덱스는 2로 바뀐다.
      dp[i][0][2] = dp[i][0][2] + dp[i-1][1][3] + dp[i-1][1][4] + dp[i-1][1][5]
    
    elif j == 9 :
      #마지막 수가 9라면 그 앞에는 8만 올 수 있으므로 증가하는 경우 밖에 없음.

      #이미 1번 증가한 상태
      #증가한 상태에서 또 증가하므로 3차원 배열 인덱스는 5로 바뀐다.
      dp[i][9][5] = dp[i][9][5] + dp[i-1][8][4]

      #증가한 적이 없는 상태
      #마지막 수로 9가 오면서 증가하기 때문에 3차원 배열 인덱스는 4로 바뀐다.
      dp[i][9][4] = dp[i][9][4] + dp[i-1][8][3] + dp[i-1][8][2] + dp[i-1][8][1]

    else :
    #증가하는 경우 -> 그 전 dp를 참조할 때 : j-1
      #이미 1번 증가한 경우
      dp[i][j][5] = dp[i][j][5] + dp[i-1][j-1][4]

      #이전에 증가한 적이 없는 경우 -> 3차원 배열 인덱스가 4로 바뀜.
      dp[i][j][4] = dp[i][j][4] + dp[i-1][j-1][1] + dp[i-1][j-1][2] + dp[i-1][j-1][3]
    
    #감소하는 경우 -> 그 전 dp를 참조할 때 : j+1
      #이미 1번 감소한 경우
      dp[i][j][1] = dp[i][j][1] + dp[i-1][j+1][2]

      #이전에 감소한 적이 없는 경우 -> 3차원 배열 인덱스가 2로 바뀜.
      dp[i][j][2] = dp[i][j][2] + dp[i-1][j+1][3] + dp[i-1][j+1][4] + dp[i-1][j+1][5]

res = 0
for j in range(10) :
  for k in range(1,6) :
    res = res + dp[n][j][k]

res = res % mod

print(res)